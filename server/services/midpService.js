const { v4: uuidv4 } = require('uuid');
const { format, addDays, parseISO, differenceInDays } = require('date-fns');
const _ = require('lodash');
const tidpService = require('./tidpService');
const db = require('../db/database');

// Safe date parsing helper - returns null for invalid dates
function safeParseDateForSort(dateValue) {
  if (!dateValue) return new Date('9999-12-31');
  try {
    const date = new Date(dateValue);
    if (isNaN(date.getTime())) return new Date('9999-12-31');
    return date;
  } catch {
    return new Date('9999-12-31');
  }
}

// Safe date validation helper - returns true if date is valid
function isValidDate(dateValue) {
  if (!dateValue) return false;
  try {
    const date = new Date(dateValue);
    return !isNaN(date.getTime());
  } catch {
    return false;
  }
}

class MIDPService {
  constructor() {
    // SQLite database for persistent storage
  }

  /**
   * Auto-generate MIDP from ALL TIDPs in the database (no projectId filter)
   * @param {Object} midpData - Basic MIDP information
   * @returns {Object} Generated MIDP
   */
  autoGenerateMIDPFromAll(midpData = {}) {
    const allTidps = tidpService.getAllTIDPs();

    if (allTidps.length === 0) {
      throw new Error('No TIDPs found. Create at least one TIDP before generating an MIDP.');
    }

    const tidpIds = allTidps.map(t => t.id);

    const midp = {
      id: uuidv4(),
      projectName: midpData.projectName || 'Master Information Delivery Plan',
      description: midpData.description || `Auto-generated MIDP from ${allTidps.length} TIDPs`,
      projectId: null,
      includedTIDPs: tidpIds,
      aggregatedData: this.aggregateTIDPs(allTidps),
      deliverySchedule: this.generateDeliverySchedule(allTidps),
      riskRegister: this.consolidateRisks(allTidps),
      dependencyMatrix: this.generateDependencyMatrixFromTIDPs(allTidps),
      resourcePlan: this.generateResourcePlan(allTidps),
      qualityGates: this.defineQualityGates(allTidps),
      evolutionHistory: this.createEvolutionSnapshot(allTidps),
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      version: '1.0',
      status: 'Active',
      autoGenerated: true
    };

    // Insert MIDP into database
    const insertMidp = db.prepare(`
      INSERT INTO midps (id, projectName, aggregated_data, delivery_schedule, included_tidps, risk_register, dependency_matrix, resource_plan, description, quality_gates, projectId, createdAt, updatedAt, version, status)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `);

    insertMidp.run(
      midp.id,
      midp.projectName,
      JSON.stringify(midp.aggregatedData || {}),
      JSON.stringify(midp.deliverySchedule || {}),
      JSON.stringify(midp.includedTIDPs || []),
      JSON.stringify(midp.riskRegister || {}),
      JSON.stringify(midp.dependencyMatrix || {}),
      JSON.stringify(midp.resourcePlan || {}),
      midp.description || '',
      JSON.stringify(midp.qualityGates || []),
      midp.projectId,
      midp.createdAt,
      midp.updatedAt,
      midp.version,
      midp.status
    );

    // Persist evolution snapshot
    this.persistEvolutionSnapshot(midp.id, midp.evolutionHistory);

    return midp;
  }

  /**
   * Auto-generate MIDP from all TIDPs in a project
   * @param {string} projectId - Project ID
   * @param {Object} midpData - Basic MIDP information
   * @returns {Object} Generated MIDP
   */
  autoGenerateMIDPFromProject(projectId, midpData = {}) {
    const allTidps = tidpService.getTIDPsByProject(projectId);

    if (allTidps.length === 0) {
      throw new Error(`No TIDPs found for project ${projectId}`);
    }

    const tidpIds = allTidps.map(t => t.id);

    const midp = {
      id: uuidv4(),
      projectName: midpData.projectName || `Project ${projectId}`,
      description: midpData.description || `Auto-generated MIDP from ${allTidps.length} TIDPs`,
      projectId,
      includedTIDPs: tidpIds,
      aggregatedData: this.aggregateTIDPs(allTidps),
      deliverySchedule: this.generateDeliverySchedule(allTidps),
      riskRegister: this.consolidateRisks(allTidps),
      dependencyMatrix: this.generateDependencyMatrixFromTIDPs(allTidps),
      resourcePlan: this.generateResourcePlan(allTidps),
      qualityGates: this.defineQualityGates(allTidps),
      evolutionHistory: this.createEvolutionSnapshot(allTidps),
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      version: '1.0',
      status: 'Active',
      autoGenerated: true
    };

    // Insert MIDP into database
    const insertMidp = db.prepare(`
      INSERT INTO midps (id, projectName, aggregated_data, delivery_schedule, included_tidps, risk_register, dependency_matrix, resource_plan, description, quality_gates, projectId, createdAt, updatedAt, version, status)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `);

    insertMidp.run(
      midp.id,
      midp.projectName,
      JSON.stringify(midp.aggregatedData || {}),
      JSON.stringify(midp.deliverySchedule || {}),
      JSON.stringify(midp.includedTIDPs || []),
      JSON.stringify(midp.riskRegister || {}),
      JSON.stringify(midp.dependencyMatrix || {}),
      JSON.stringify(midp.resourcePlan || {}),
      midp.description || '',
      JSON.stringify(midp.qualityGates || []),
      midp.projectId,
      midp.createdAt,
      midp.updatedAt,
      midp.version,
      midp.status
    );

    // Persist evolution snapshot
    this.persistEvolutionSnapshot(midp.id, midp.evolutionHistory);

    return midp;
  }

  /**
   * Create MIDP by aggregating TIDPs (legacy - for backward compatibility)
   * @param {Object} midpData - Basic MIDP information
   * @param {Array} tidpIds - Array of TIDP IDs to include
   * @returns {Object} Generated MIDP
   */
  createMIDPFromTIDPs(midpData, tidpIds) {
    const tidps = tidpIds.map(id => tidpService.getTIDP(id));

    const midp = {
      id: uuidv4(),
      ...midpData,
      includedTIDPs: tidpIds,
      aggregatedData: this.aggregateTIDPs(tidps),
      deliverySchedule: this.generateDeliverySchedule(tidps),
      riskRegister: this.consolidateRisks(tidps),
      dependencyMatrix: this.generateDependencyMatrixFromTIDPs(tidps),
      resourcePlan: this.generateResourcePlan(tidps),
      qualityGates: this.defineQualityGates(tidps),
      evolutionHistory: this.createEvolutionSnapshot(tidps),
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      version: '1.0',
      status: 'Active'
    };

    // Insert MIDP into database
    const insertMidp = db.prepare(`
      INSERT INTO midps (id, projectName, aggregated_data, delivery_schedule, included_tidps, risk_register, dependency_matrix, resource_plan, description, quality_gates, projectId, createdAt, updatedAt, version, status)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `);

    insertMidp.run(
      midp.id,
      midp.projectName || midpData.projectName,
      JSON.stringify(midp.aggregatedData || {}),
      JSON.stringify(midp.deliverySchedule || {}),
      JSON.stringify(midp.includedTIDPs || []),
      JSON.stringify(midp.riskRegister || {}),
      JSON.stringify(midp.dependencyMatrix || {}),
      JSON.stringify(midp.resourcePlan || {}),
      midpData.description || '',
      JSON.stringify(midp.qualityGates || []),
      midpData.projectId || null,
      midp.createdAt,
      midp.updatedAt,
      midp.version,
      midp.status
    );

    // Persist evolution snapshot
    this.persistEvolutionSnapshot(midp.id, midp.evolutionHistory);

    return midp;
  }

  /**
   * Update MIDP with new TIDP data
   * @param {string} midpId - MIDP ID
   * @param {Array} updatedTidpIds - Updated TIDP IDs
   * @returns {Object} Updated MIDP
   */
  updateMIDPFromTIDPs(midpId, updatedTidpIds) {
    const existingMidp = this.getMIDP(midpId);
    if (!existingMidp) {
      throw new Error(`MIDP with ID ${midpId} not found`);
    }

    const tidps = updatedTidpIds.map(id => tidpService.getTIDP(id));

    const updatedAt = new Date().toISOString();
    const version = this.incrementVersion(existingMidp.version);

    const aggregatedData = this.aggregateTIDPs(tidps);
    const deliverySchedule = this.generateDeliverySchedule(tidps);
    const riskRegister = this.consolidateRisks(tidps);
    const dependencyMatrix = this.generateDependencyMatrixFromTIDPs(tidps);
    const resourcePlan = this.generateResourcePlan(tidps);

    // Update MIDP
    const updateStmt = db.prepare(`
      UPDATE midps
      SET aggregated_data = ?, delivery_schedule = ?, included_tidps = ?, risk_register = ?, dependency_matrix = ?, resource_plan = ?, updatedAt = ?, version = ?
      WHERE id = ?
    `);

    updateStmt.run(
      JSON.stringify(aggregatedData),
      JSON.stringify(deliverySchedule),
      JSON.stringify(updatedTidpIds),
      JSON.stringify(riskRegister),
      JSON.stringify(dependencyMatrix),
      JSON.stringify(resourcePlan),
      updatedAt,
      version,
      midpId
    );

    // Persist evolution snapshot on update
    const snapshot = this.createEvolutionSnapshot(tidps);
    this.persistEvolutionSnapshot(midpId, snapshot);

    return this.getMIDP(midpId);
  }

  /**
   * Aggregate TIDP data into consolidated format
   * @param {Array} tidps - Array of TIDP objects
   * @returns {Object} Aggregated data
   */
  aggregateTIDPs(tidps) {
    const containers = [];
    const milestones = new Map();
    const disciplines = new Set();
    const totalEstimatedHours = new Map();

    tidps.forEach(tidp => {
      disciplines.add(tidp.discipline);

      if (tidp.containers) {
        tidp.containers.forEach(container => {
          const aggregatedContainer = {
            id: container.id,
            name: container['Container Name'] || container.name,
            type: container.Type || container.type,
            format: container.Format || container.format,
            loiLevel: container['LOI Level'] || container.levelOfInformation,
            author: container.Author || container.author,
            tidpSource: {
              id: tidp.id,
              teamName: tidp.teamName,
              discipline: tidp.discipline
            },
            estimatedTime: container['Est. Time'] || container.estimatedProductionTime,
            milestone: container.Milestone || container.deliveryMilestone,
            dueDate: container['Due Date'] || container.dueDate,
            status: container.Status || container.status,
            dependencies: this.processDependencies(container.dependencies || [], tidps)
          };

          containers.push(aggregatedContainer);

          // Group by milestone
          const milestone = aggregatedContainer.milestone;
          if (milestone) {
            if (!milestones.has(milestone)) {
              milestones.set(milestone, {
                name: milestone,
                containers: [],
                teams: new Set(),
                earliestDate: aggregatedContainer.dueDate,
                latestDate: aggregatedContainer.dueDate,
                totalEstimatedHours: 0
              });
            }

            const ms = milestones.get(milestone);
            ms.containers.push(aggregatedContainer);
            ms.teams.add(tidp.teamName);

            // Update date range
            if (aggregatedContainer.dueDate) {
              if (!ms.earliestDate || aggregatedContainer.dueDate < ms.earliestDate) {
                ms.earliestDate = aggregatedContainer.dueDate;
              }
              if (!ms.latestDate || aggregatedContainer.dueDate > ms.latestDate) {
                ms.latestDate = aggregatedContainer.dueDate;
              }
            }

            // Add estimated hours
            const hours = this.parseTimeToHours(aggregatedContainer.estimatedTime);
            ms.totalEstimatedHours += hours;

            // Track by discipline
            const discipline = tidp.discipline;
            if (!totalEstimatedHours.has(discipline)) {
              totalEstimatedHours.set(discipline, 0);
            }
            totalEstimatedHours.set(discipline, totalEstimatedHours.get(discipline) + hours);
          }
        });
      }
    });

    return {
      containers,
      milestones: Array.from(milestones.values()).map(ms => ({
        ...ms,
        teams: Array.from(ms.teams),
        reviewDuration: this.calculateReviewDuration(ms.containers.length),
        riskLevel: this.assessMilestoneRisk(ms),
        delayImpact: this.checkDelayImpact(ms, tidps) // Enhanced: Check for delay impacts
      })),
      disciplines: Array.from(disciplines),
      totalContainers: containers.length,
      totalEstimatedHours: Array.from(totalEstimatedHours.values()).reduce((sum, hours) => sum + hours, 0),
      estimatedHoursByDiscipline: Object.fromEntries(totalEstimatedHours)
    };
  }

  /**
   * Generate delivery schedule with critical path analysis
   * @param {Array} tidps - Array of TIDP objects
   * @returns {Object} Delivery schedule
   */
  generateDeliverySchedule(tidps) {
    const schedule = {
      phases: [],
      criticalPath: [],
      bufferAnalysis: {},
      recommendedSequence: []
    };

    // Extract all containers with dates
    const allContainers = [];
    tidps.forEach(tidp => {
      if (tidp.containers) {
        tidp.containers.forEach(container => {
          if (container['Due Date'] || container.dueDate) {
            allContainers.push({
              ...container,
              tidpId: tidp.id,
              teamName: tidp.teamName,
              discipline: tidp.discipline,
              dueDate: container['Due Date'] || container.dueDate
            });
          }
        });
      }
    });

    // Sort by due date (safely)
    allContainers.sort((a, b) => safeParseDateForSort(a.dueDate) - safeParseDateForSort(b.dueDate));

    // Group into phases (monthly) - only include containers with valid dates
    const containersWithValidDates = allContainers.filter(c => isValidDate(c.dueDate));
    const phases = _.groupBy(containersWithValidDates, container => {
      const date = new Date(container.dueDate);
      return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
    });

    schedule.phases = Object.entries(phases).map(([period, containers]) => ({
      period,
      containerCount: containers.length,
      disciplines: _.uniq(containers.map(c => c.discipline)),
      totalEstimatedHours: containers.reduce((sum, c) =>
        sum + this.parseTimeToHours(c['Est. Time'] || c.estimatedProductionTime || '0'), 0
      ),
      containers: containers.map(c => ({
        id: c.id,
        name: c['Container Name'] || c.name,
        team: c.teamName,
        dueDate: c.dueDate
      }))
    }));

    // Identify critical path (simplified)
    schedule.criticalPath = this.identifyCriticalPath(allContainers);

    // Buffer analysis
    schedule.bufferAnalysis = this.analyzeBuffers(allContainers);

    return schedule;
  }

  /**
   * Consolidate risks from all TIDPs
   * @param {Array} tidps - Array of TIDP objects
   * @returns {Array} Consolidated risk register
   */
  consolidateRisks(tidps) {
    const risks = [];
    const riskCategories = new Map();

    tidps.forEach(tidp => {
      // Add TIDP-specific risks
      if (tidp.risks) {
        tidp.risks.forEach(risk => {
          risks.push({
            id: uuidv4(),
            ...risk,
            source: `TIDP: ${tidp.teamName}`,
            category: risk.category || 'Information Delivery'
          });
        });
      }

      // Analyze containers for potential risks
      if (tidp.containers) {
        tidp.containers.forEach(container => {
          // Dependency risks
          if (container.dependencies && container.dependencies.length > 2) {
            risks.push({
              id: uuidv4(),
              description: `High dependency count for ${container['Container Name'] || container.name}`,
              impact: 'Medium',
              probability: 'Medium',
              category: 'Dependency',
              mitigation: 'Review and simplify dependencies where possible',
              source: `Auto-detected from ${tidp.teamName}`,
              affectedContainer: container.id
            });
          }

          // Timeline risks
          if (container['Est. Time'] || container.estimatedProductionTime) {
            const hours = this.parseTimeToHours(container['Est. Time'] || container.estimatedProductionTime);
            if (hours > 200) { // More than 5 weeks
              risks.push({
                id: uuidv4(),
                description: `Extended timeline for ${container['Container Name'] || container.name}`,
                impact: 'High',
                probability: 'Medium',
                category: 'Schedule',
                mitigation: 'Consider breaking into smaller deliverables',
                source: `Auto-detected from ${tidp.teamName}`,
                affectedContainer: container.id
              });
            }
          }

          // Rule 3: Overdue deliverables - due date in the past and not completed/approved
          const dueDate = container['Due Date'] || container.dueDate;
          const containerStatus = (container.Status || container.status || '').toLowerCase();
          if (dueDate && isValidDate(dueDate)) {
            const due = new Date(dueDate);
            if (due < new Date() && !['completed', 'approved'].includes(containerStatus)) {
              risks.push({
                id: uuidv4(),
                description: `Overdue deliverable: ${container['Container Name'] || container.name} was due ${dueDate}`,
                impact: 'High',
                probability: 'High',
                category: 'Schedule',
                mitigation: 'Escalate to project manager, reallocate resources or renegotiate deadline',
                source: `Auto-detected from ${tidp.teamName}`,
                affectedContainer: container.id
              });
            }
          }

          // Rule 4: Missing Level of Information Need
          const loi = container['LOI Level'] || container['Level of Information Need (LOIN)'] || container.loin;
          if (!loi || loi.trim() === '') {
            risks.push({
              id: uuidv4(),
              description: `Missing Level of Information Need for ${container['Container Name'] || container.name}`,
              impact: 'Medium',
              probability: 'High',
              category: 'Compliance',
              mitigation: 'Define LOI/LOD level per ISO 19650 requirements before production begins',
              source: `Auto-detected from ${tidp.teamName}`,
              affectedContainer: container.id
            });
          }

          // Rule 6: Cross-discipline dependency (check if dependencies span different disciplines)
          if (container.dependencies && container.dependencies.length > 0) {
            container.dependencies.forEach(depId => {
              const depTidp = tidps.find(t =>
                t.containers && t.containers.some(c => c.id === depId)
              );
              if (depTidp && depTidp.discipline !== tidp.discipline) {
                risks.push({
                  id: uuidv4(),
                  description: `Cross-discipline dependency: ${container['Container Name'] || container.name} (${tidp.discipline}) depends on ${depTidp.teamName} (${depTidp.discipline})`,
                  impact: 'Medium',
                  probability: 'Medium',
                  category: 'Coordination',
                  mitigation: 'Establish formal coordination protocol between disciplines, assign liaison contact',
                  source: `Auto-detected from ${tidp.teamName}`,
                  affectedContainer: container.id
                });
              }
            });
          }
        });
      }
    });

    // Rule 5: Milestone congestion - >10 containers targeting the same milestone
    const milestoneCount = new Map();
    tidps.forEach(tidp => {
      if (tidp.containers) {
        tidp.containers.forEach(container => {
          const milestone = container.Milestone || container.deliveryMilestone || container['Delivery Milestone'];
          if (milestone) {
            milestoneCount.set(milestone, (milestoneCount.get(milestone) || 0) + 1);
          }
        });
      }
    });
    milestoneCount.forEach((count, milestone) => {
      if (count > 10) {
        risks.push({
          id: uuidv4(),
          description: `Milestone congestion: ${count} containers target "${milestone}" milestone`,
          impact: 'High',
          probability: 'Medium',
          category: 'Schedule',
          mitigation: 'Stagger deliverable due dates, add buffer time before milestone, or split into sub-milestones',
          source: 'Auto-detected from aggregated analysis'
        });
      }
    });

    // Categorize and prioritize risks
    risks.forEach(risk => {
      const category = risk.category || 'General';
      if (!riskCategories.has(category)) {
        riskCategories.set(category, []);
      }
      riskCategories.get(category).push(risk);
    });

    return {
      risks: risks.sort((a, b) => this.getRiskScore(b) - this.getRiskScore(a)),
      categories: Object.fromEntries(riskCategories),
      summary: {
        total: risks.length,
        high: risks.filter(r => r.impact === 'High').length,
        medium: risks.filter(r => r.impact === 'Medium').length,
        low: risks.filter(r => r.impact === 'Low').length
      }
    };
  }

  /**
   * Generate resource allocation plan
   * @param {Array} tidps - Array of TIDP objects
   * @returns {Object} Resource plan
   */
  generateResourcePlan(tidps) {
    const plan = {
      byDiscipline: {},
      byTimePeriod: {},
      peakUtilization: {},
      recommendations: []
    };

    tidps.forEach(tidp => {
      const discipline = tidp.discipline;

      if (!plan.byDiscipline[discipline]) {
        plan.byDiscipline[discipline] = {
          teams: 0,
          totalHours: 0,
          containers: 0,
          peakMonth: null,
          peakHours: 0
        };
      }

      plan.byDiscipline[discipline].teams += 1;

      if (tidp.containers) {
        plan.byDiscipline[discipline].containers += tidp.containers.length;

        tidp.containers.forEach(container => {
          const hours = this.parseTimeToHours(container['Est. Time'] || container.estimatedProductionTime || '0');
          plan.byDiscipline[discipline].totalHours += hours;

          // Track by time period
          const dueDate = container['Due Date'] || container.dueDate;
          if (dueDate && isValidDate(dueDate)) {
            const period = format(new Date(dueDate), 'yyyy-MM');

            if (!plan.byTimePeriod[period]) {
              plan.byTimePeriod[period] = {
                totalHours: 0,
                disciplines: new Set(),
                containers: 0
              };
            }

            plan.byTimePeriod[period].totalHours += hours;
            plan.byTimePeriod[period].disciplines.add(discipline);
            plan.byTimePeriod[period].containers += 1;
          }
        });
      }
    });

    // Convert sets to arrays
    Object.keys(plan.byTimePeriod).forEach(period => {
      plan.byTimePeriod[period].disciplines = Array.from(plan.byTimePeriod[period].disciplines);
    });

    // Identify peak utilization
    const periods = Object.entries(plan.byTimePeriod);
    if (periods.length > 0) {
      const peakPeriod = periods.reduce((max, [period, data]) =>
        data.totalHours > max[1].totalHours ? [period, data] : max
      );

      plan.peakUtilization = {
        period: peakPeriod[0],
        hours: peakPeriod[1].totalHours,
        disciplines: peakPeriod[1].disciplines.length
      };
    }

    // Generate recommendations
    plan.recommendations = this.generateResourceRecommendations(plan);

    return plan;
  }

  /**
   * Define quality gates based on aggregated information
   * @param {Array} tidps - Array of TIDP objects
   * @returns {Array} Quality gates
   */
  defineQualityGates(tidps) {
    const gates = [];
    const milestones = new Set();

    tidps.forEach(tidp => {
      if (tidp.containers) {
        tidp.containers.forEach(container => {
          const milestone = container.Milestone || container.deliveryMilestone;
          if (milestone) {
            milestones.add(milestone);
          }
        });
      }
    });

    milestones.forEach(milestone => {
      gates.push({
        id: uuidv4(),
        name: `Quality Gate: ${milestone}`,
        milestone,
        criteria: [
          'All information containers completed and validated',
          'Clash detection performed and conflicts resolved',
          'Model federation successful',
          'Quality assurance checks passed',
          'Client review and approval obtained'
        ],
        approvers: ['Information Manager', 'Project Director', 'Client Representative'],
        estimatedDuration: '1 week',
        dependencies: [`Completion of all ${milestone} deliverables`]
      });
    });

    return gates.sort((a, b) => a.milestone.localeCompare(b.milestone));
  }

  // Helper methods
  parseTimeToHours(timeString) {
    if (!timeString) return 0;

    const timeStr = timeString.toString().toLowerCase();

    if (timeStr.includes('week')) {
      const weeks = parseFloat(timeStr);
      return weeks * 40;
    } else if (timeStr.includes('day')) {
      const days = parseFloat(timeStr);
      return days * 8;
    } else if (timeStr.includes('hour')) {
      return parseFloat(timeStr);
    }

    return 0;
  }

  processDependencies(dependencies, allTidps) {
    return dependencies.map(depId => {
      const sourceTidp = allTidps.find(tidp =>
        tidp.containers && tidp.containers.some(c => c.id === depId)
      );

      if (sourceTidp) {
        const sourceContainer = sourceTidp.containers.find(c => c.id === depId);
        return {
          dependencyId: depId,
          sourceTeam: sourceTidp.teamName,
          sourceDiscipline: sourceTidp.discipline,
          sourceContainer: sourceContainer ? sourceContainer['Container Name'] || sourceContainer.name : 'Unknown',
          type: 'information'
        };
      }

      return {
        dependencyId: depId,
        type: 'external'
      };
    });
  }

  calculateReviewDuration(containerCount) {
    // Base 1 week + 1 day per 3 containers
    const baseDays = 5; // 1 week
    const additionalDays = Math.ceil(containerCount / 3);
    const totalDays = baseDays + additionalDays;

    return `${Math.ceil(totalDays / 5)} week${totalDays > 5 ? 's' : ''}`;
  }

  assessMilestoneRisk(milestone) {
    let riskLevel = 'Low';

    if (milestone.containers.length > 10) riskLevel = 'Medium';
    if (milestone.containers.length > 20) riskLevel = 'High';
    if (milestone.teams.length > 5) riskLevel = 'High';
    if (milestone.totalEstimatedHours > 500) riskLevel = 'High';

    return riskLevel;
  }

  identifyCriticalPath(containers) {
    // Delegate to tidpService's real CPM algorithm
    // Build pseudo-TIDP array from flat containers for the CPM input
    const pseudoTidp = {
      id: 'midp-aggregate',
      teamName: 'Aggregate',
      discipline: 'All',
      containers: containers.map(c => ({
        id: c.id,
        'Container Name': c['Container Name'] || c.name,
        'Est. Time': c['Est. Time'] || c.estimatedProductionTime || '0',
        dependencies: c.dependencies || [],
        'Due Date': c['Due Date'] || c.dueDate
      }))
    };

    const cpResult = tidpService.calculateCriticalPath([pseudoTidp]);
    return cpResult.map(c => c.id);
  }

  analyzeBuffers(containers) {
    // Simplified buffer analysis
    return {
      recommendedBuffer: '10%',
      criticalContainers: containers.filter(c => c.dependencies && c.dependencies.length > 2).length,
      averageLeadTime: '2 weeks'
    };
  }

  getRiskScore(risk) {
    const impactScore = { 'Low': 1, 'Medium': 2, 'High': 3, 'Critical': 4 };
    const probabilityScore = { 'Low': 1, 'Medium': 2, 'High': 3 };

    return (impactScore[risk.impact] || 1) * (probabilityScore[risk.probability] || 1);
  }

  generateResourceRecommendations(plan) {
    const recommendations = [];

    // Check for peak utilization
    if (plan.peakUtilization.hours > 400) {
      recommendations.push({
        type: 'workload',
        priority: 'High',
        message: `Peak utilization in ${plan.peakUtilization.period} requires resource balancing`,
        action: 'Consider redistributing workload or adding temporary resources'
      });
    }

    // Check discipline balance
    const disciplineHours = Object.values(plan.byDiscipline).map(d => d.totalHours);
    const maxHours = Math.max(...disciplineHours);
    const minHours = Math.min(...disciplineHours);

    if (maxHours > minHours * 3) {
      recommendations.push({
        type: 'balance',
        priority: 'Medium',
        message: 'Uneven workload distribution across disciplines',
        action: 'Review scope distribution and consider load balancing'
      });
    }

    return recommendations;
  }

  /**
   * Generate dependency matrix from TIDPs
   * @param {Array} tidps - Array of TIDP objects
   * @returns {Object} Dependency matrix
   */
  generateDependencyMatrixFromTIDPs(tidps) {
    const matrix = [];
    const summary = {
      totalDependencies: 0,
      criticalDependencies: 0,
      teamsInvolved: new Set()
    };

    tidps.forEach(tidp => {
      if (tidp.containers) {
        tidp.containers.forEach(container => {
          const dependencies = container.Dependencies || container.dependencies || [];

          dependencies.forEach(depId => {
            const dependencyTidp = tidps.find(t =>
              t.containers && t.containers.some(c => c.id === depId)
            );

            if (dependencyTidp) {
              const depContainer = dependencyTidp.containers.find(c => c.id === depId);

              matrix.push({
                from: {
                  tidpId: dependencyTidp.id,
                  tidpName: dependencyTidp.teamName,
                  containerId: depId,
                  containerName: depContainer ? (depContainer['Container Name'] || depContainer.name) : 'Unknown'
                },
                to: {
                  tidpId: tidp.id,
                  tidpName: tidp.teamName,
                  containerId: container.id,
                  containerName: container['Container Name'] || container.name
                },
                type: 'information_dependency',
                criticalPath: false // Simplified for now
              });

              summary.totalDependencies += 1;
              summary.teamsInvolved.add(tidp.teamName);
              summary.teamsInvolved.add(dependencyTidp.teamName);
            }
          });
        });
      }
    });

    summary.teamsInvolved = summary.teamsInvolved.size;

    return {
      matrix,
      summary
    };
  }

  incrementVersion(currentVersion) {
    const parts = currentVersion.split('.');
    const minor = parseInt(parts[1] || 0) + 1;
    return `${parts[0]}.${minor}.0`;
  }

  getMIDP(id) {
    const midp = db.prepare('SELECT * FROM midps WHERE id = ?').get(id);
    if (!midp) {
      throw new Error(`MIDP with ID ${id} not found`);
    }

    // Parse JSON fields
    return {
      id: midp.id,
      projectName: midp.projectName,
      aggregatedData: JSON.parse(midp.aggregated_data || '{}'),
      deliverySchedule: JSON.parse(midp.delivery_schedule || '{}'),
      includedTIDPs: JSON.parse(midp.included_tidps || '[]'),
      riskRegister: JSON.parse(midp.risk_register || '{}'),
      dependencyMatrix: JSON.parse(midp.dependency_matrix || '{}'),
      resourcePlan: JSON.parse(midp.resource_plan || '{}'),
      description: midp.description,
      qualityGates: JSON.parse(midp.quality_gates || '[]'),
      projectId: midp.projectId,
      createdAt: midp.createdAt,
      updatedAt: midp.updatedAt,
      version: midp.version,
      status: midp.status
    };
  }

  getAllMIDPs() {
    const midps = db.prepare('SELECT * FROM midps').all();
    return midps.map(m => this.getMIDP(m.id));
  }

  deleteMIDP(id) {
    const midp = db.prepare('SELECT * FROM midps WHERE id = ?').get(id);
    if (!midp) {
      throw new Error(`MIDP with ID ${id} not found`);
    }

    const result = db.prepare('DELETE FROM midps WHERE id = ?').run(id);
    return result.changes > 0;
  }

  /**
   * Create evolution snapshot for tracking MIDP changes over time
   * @param {Array} tidps - Array of TIDP objects
   * @returns {Object} Evolution snapshot
   */
  createEvolutionSnapshot(tidps) {
    const snapshot = {
      timestamp: new Date().toISOString(),
      tidpCount: tidps.length,
      totalContainers: 0,
      totalEstimatedHours: 0,
      deliverablesByMilestone: {},
      teamsByDiscipline: {},
      completionStatus: {
        planned: 0,
        inProgress: 0,
        completed: 0,
        delayed: 0
      }
    };

    tidps.forEach(tidp => {
      // Track teams by discipline
      if (!snapshot.teamsByDiscipline[tidp.discipline]) {
        snapshot.teamsByDiscipline[tidp.discipline] = 0;
      }
      snapshot.teamsByDiscipline[tidp.discipline] += 1;

      if (tidp.containers) {
        snapshot.totalContainers += tidp.containers.length;

        tidp.containers.forEach(container => {
          // Count total hours
          const hours = this.parseTimeToHours(container['Est. Time'] || container.estimatedProductionTime || '0');
          snapshot.totalEstimatedHours += hours;

          // Group by milestone
          const milestone = container.Milestone || container.deliveryMilestone || 'Unassigned';
          if (!snapshot.deliverablesByMilestone[milestone]) {
            snapshot.deliverablesByMilestone[milestone] = {
              count: 0,
              estimatedHours: 0,
              teams: new Set()
            };
          }
          snapshot.deliverablesByMilestone[milestone].count += 1;
          snapshot.deliverablesByMilestone[milestone].estimatedHours += hours;
          snapshot.deliverablesByMilestone[milestone].teams.add(tidp.teamName);

          // Track completion status
          const status = container.Status || container.status || 'Planned';
          const statusKey = status.toLowerCase().replace(' ', '');
          if (snapshot.completionStatus.hasOwnProperty(statusKey)) {
            snapshot.completionStatus[statusKey] += 1;
          } else {
            snapshot.completionStatus.planned += 1; // Default to planned
          }
        });
      }
    });

    // Convert sets to arrays
    Object.keys(snapshot.deliverablesByMilestone).forEach(milestone => {
      snapshot.deliverablesByMilestone[milestone].teams = Array.from(snapshot.deliverablesByMilestone[milestone].teams);
    });

    return snapshot;
  }

  /**
   * Persist an evolution snapshot to the database
   * @param {string} midpId - MIDP ID
   * @param {Object} snapshotData - Snapshot data to persist
   */
  persistEvolutionSnapshot(midpId, snapshotData) {
    try {
      const insertSnapshot = db.prepare(`
        INSERT INTO evolution_snapshots (id, midp_id, snapshot_data, created_at)
        VALUES (?, ?, ?, ?)
      `);
      insertSnapshot.run(
        uuidv4(),
        midpId,
        JSON.stringify(snapshotData || {}),
        new Date().toISOString()
      );
    } catch (err) {
      console.warn('Failed to persist evolution snapshot:', err.message);
    }
  }

  /**
   * Get MIDP evolution over time using real persisted snapshots
   * @param {string} midpId - MIDP ID
   * @returns {Object} Evolution data for dashboard
   */
  getMIDPEvolution(midpId) {
    const midp = this.getMIDP(midpId);

    // Fetch real historical snapshots from database
    const snapshots = db.prepare(

      'SELECT * FROM evolution_snapshots WHERE midp_id = ? ORDER BY created_at ASC'
    ).all(midpId);

    const historical = snapshots.map(s => {
      const data = JSON.parse(s.snapshot_data || '{}');
      return {
        timestamp: s.created_at,
        tidpCount: data.tidpCount || 0,
        totalContainers: data.totalContainers || 0,
        totalEstimatedHours: data.totalEstimatedHours || 0,
        completionStatus: data.completionStatus || {},
        deliverablesByMilestone: data.deliverablesByMilestone || {},
        teamsByDiscipline: data.teamsByDiscipline || {}
      };
    });

    // Current state is the latest snapshot, or compute from current MIDP data
    const current = historical.length > 0
      ? historical[historical.length - 1]
      : (midp.evolutionHistory || this.createEvolutionSnapshot([]));

    return {
      current,
      historical
    };
  }

  /**
   * Get deliverables dashboard data
   * @param {string} midpId - MIDP ID
   * @returns {Object} Dashboard data showing deliverables as spreadsheet rows
   */
  getDeliverablesDashboard(midpId) {
    const midp = this.getMIDP(midpId);
    const tidps = midp.includedTIDPs?.map(id => tidpService.getTIDP(id)) || [];

    const deliverables = [];

    tidps.forEach(tidp => {
      if (tidp.containers) {
        tidp.containers.forEach(container => {
          deliverables.push({
            id: container.id,
            containerName: container['Container Name'] || container.name,
            team: tidp.teamName,
            discipline: tidp.discipline,
            type: container.Type || container.type,
            format: container.Format || container.format,
            loiLevel: container['LOI Level'] || container.levelOfInformation,
            author: container.Author || container.author,
            estimatedTime: container['Est. Time'] || container.estimatedProductionTime,
            milestone: container.Milestone || container.deliveryMilestone,
            dueDate: container['Due Date'] || container.dueDate,
            status: container.Status || container.status,
            lastUpdated: tidp.updatedAt
          });
        });
      }
    });

    // Sort by due date (safely)
    deliverables.sort((a, b) => {
      const dateA = safeParseDateForSort(a.dueDate);
      const dateB = safeParseDateForSort(b.dueDate);
      return dateA - dateB;
    });

    return {
      deliverables,
      summary: {
        total: deliverables.length,
        byStatus: deliverables.reduce((acc, d) => {
          const status = d.status || 'Planned';
          acc[status] = (acc[status] || 0) + 1;
          return acc;
        }, {}),
        byMilestone: deliverables.reduce((acc, d) => {
          const milestone = d.milestone || 'Unassigned';
          acc[milestone] = (acc[milestone] || 0) + 1;
          return acc;
        }, {}),
        byDiscipline: deliverables.reduce((acc, d) => {
          acc[d.discipline] = (acc[d.discipline] || 0) + 1;
          return acc;
        }, {})
      }
    };
  }

  /**
   * Check for delay impact on milestone
   * @param {Object} milestone - Milestone object
   * @param {Array} allTidps - All TIDPs for comparison
   * @returns {boolean} Whether there's a delay impact
   */
  checkDelayImpact(milestone, allTidps) {
    // Check if any TIDP due dates exceed the milestone's latest date
    return milestone.containers.some(container => {
      if (!container.dueDate || !milestone.latestDate) return false;
      if (!isValidDate(container.dueDate) || !isValidDate(milestone.latestDate)) return false;
      return new Date(container.dueDate) > new Date(milestone.latestDate);
    });
  }

  /**
   * Calculate cascading impact of late deliverables.
   * Traces downstream dependencies from overdue containers, calculates propagated delay,
   * auto-elevates risk severity, and suggests recovery actions.
   * @param {string} midpId - MIDP ID
   * @returns {Object} Cascading impact analysis
   */
  calculateCascadingImpact(midpId) {
    const midp = this.getMIDP(midpId);
    const tidps = (midp.includedTIDPs || []).map(id => {
      try { return tidpService.getTIDP(id); } catch { return null; }
    }).filter(Boolean);

    // Build container graph
    const containerMap = new Map();
    const adjList = new Map(); // containerId -> [downstream containerIds]

    tidps.forEach(tidp => {
      if (tidp.containers) {
        tidp.containers.forEach(container => {
          containerMap.set(container.id, {
            ...container,
            tidpId: tidp.id,
            tidpName: tidp.teamName,
            discipline: tidp.discipline
          });
          if (!adjList.has(container.id)) adjList.set(container.id, []);
        });
      }
    });

    // Build reverse adjacency (container -> downstream dependents)
    tidps.forEach(tidp => {
      if (tidp.containers) {
        tidp.containers.forEach(container => {
          const deps = container.dependencies || [];
          deps.forEach(depId => {
            if (adjList.has(depId)) {
              adjList.get(depId).push(container.id);
            }
          });
        });
      }
    });

    // Find late containers
    const now = new Date();
    const lateContainers = [];

    containerMap.forEach((container, id) => {
      const dueDate = container['Due Date'] || container.dueDate;
      const status = (container.Status || container.status || '').toLowerCase();
      if (dueDate && isValidDate(dueDate)) {
        const due = new Date(dueDate);
        if (due < now && !['completed', 'approved'].includes(status)) {
          const delayDays = Math.ceil((now - due) / (1000 * 60 * 60 * 24));
          lateContainers.push({
            id,
            name: container['Container Name'] || container.name,
            tidpName: container.tidpName,
            discipline: container.discipline,
            dueDate,
            delayDays,
            status: container.Status || container.status || 'Unknown'
          });
        }
      }
    });

    // Trace cascading impact for each late container using BFS
    const impacts = lateContainers.map(lateContainer => {
      const cascade = [];
      const visited = new Set();
      const queue = [{ id: lateContainer.id, propagatedDelay: lateContainer.delayDays, depth: 0 }];
      visited.add(lateContainer.id);

      while (queue.length > 0) {
        const { id, propagatedDelay, depth } = queue.shift();
        const downstream = adjList.get(id) || [];

        downstream.forEach(downstreamId => {
          if (!visited.has(downstreamId) && containerMap.has(downstreamId)) {
            visited.add(downstreamId);
            const downstreamContainer = containerMap.get(downstreamId);
            const downstreamDuration = this.parseTimeToHours(
              downstreamContainer['Est. Time'] || downstreamContainer.estimatedProductionTime || '0'
            );
            // Propagated delay carries through but can be absorbed by buffer
            const effectiveDelay = Math.max(0, propagatedDelay);

            cascade.push({
              containerId: downstreamId,
              containerName: downstreamContainer['Container Name'] || downstreamContainer.name,
              tidpName: downstreamContainer.tidpName,
              discipline: downstreamContainer.discipline,
              propagatedDelay: effectiveDelay,
              depth: depth + 1,
              estimatedHours: downstreamDuration,
              dueDate: downstreamContainer['Due Date'] || downstreamContainer.dueDate
            });

            queue.push({ id: downstreamId, propagatedDelay: effectiveDelay, depth: depth + 1 });
          }
        });
      }

      // Determine impact severity
      const severity = cascade.length > 5 ? 'Critical'
        : cascade.length > 2 ? 'High'
        : cascade.length > 0 ? 'Medium' : 'Low';

      // Generate recovery suggestions
      const suggestions = [];
      if (lateContainer.delayDays > 14) {
        suggestions.push('Escalate to project director â€” delay exceeds 2 weeks');
      }
      if (cascade.length > 3) {
        suggestions.push('Assign additional resources to accelerate downstream deliverables');
      }
      if (cascade.some(c => c.discipline !== lateContainer.discipline)) {
        suggestions.push('Coordinate cross-discipline recovery plan with affected teams');
      }
      suggestions.push('Review and negotiate revised deadlines with appointing party');

      return {
        lateContainer,
        cascade,
        severity,
        affectedContainers: cascade.length,
        affectedDisciplines: [...new Set(cascade.map(c => c.discipline))],
        maxPropagatedDelay: cascade.length > 0 ? Math.max(...cascade.map(c => c.propagatedDelay)) : 0,
        suggestions
      };
    });

    return {
      analysisDate: now.toISOString(),
      lateContainerCount: lateContainers.length,
      totalAffected: impacts.reduce((sum, i) => sum + i.affectedContainers, 0),
      impacts: impacts.sort((a, b) => b.affectedContainers - a.affectedContainers),
      overallSeverity: impacts.some(i => i.severity === 'Critical') ? 'Critical'
        : impacts.some(i => i.severity === 'High') ? 'High'
        : impacts.length > 0 ? 'Medium' : 'Low'
    };
  }

  /**
   * Calculate trend analysis from real evolution snapshots.
   * Computes velocity (containers added/completed per period), drift, and projected completion.
   * @param {Array} snapshots - Array of historical snapshot objects
   * @returns {Object} Trend analysis data
   */
  calculateTrends(snapshots) {
    if (!snapshots || snapshots.length < 2) {
      return {
        velocity: null,
        drift: null,
        projectedCompletion: null,
        dataPoints: snapshots?.length || 0,
        message: 'Insufficient data for trend analysis (need at least 2 snapshots)'
      };
    }

    const sorted = [...snapshots].sort((a, b) =>
      new Date(a.timestamp) - new Date(b.timestamp)
    );

    // Calculate velocity: containers added per period
    const velocities = [];
    const hourDrifts = [];
    for (let i = 1; i < sorted.length; i++) {
      const prev = sorted[i - 1];
      const curr = sorted[i];
      const daysBetween = Math.max(1, (new Date(curr.timestamp) - new Date(prev.timestamp)) / (1000 * 60 * 60 * 24));

      const containersAdded = (curr.totalContainers || 0) - (prev.totalContainers || 0);
      velocities.push(containersAdded / daysBetween);

      const hoursDrift = (curr.totalEstimatedHours || 0) - (prev.totalEstimatedHours || 0);
      hourDrifts.push(hoursDrift);
    }

    const avgVelocity = velocities.reduce((s, v) => s + v, 0) / velocities.length;
    const avgHourDrift = hourDrifts.reduce((s, d) => s + d, 0) / hourDrifts.length;

    // Calculate completion status trends
    const latestSnapshot = sorted[sorted.length - 1];
    const completedCount = latestSnapshot.completionStatus?.completed || 0;
    const totalContainers = latestSnapshot.totalContainers || 1;
    const completionRate = completedCount / totalContainers;

    // Project completion date based on current velocity
    let projectedCompletion = null;
    if (avgVelocity > 0 && completionRate < 1) {
      const remainingContainers = totalContainers - completedCount;
      const daysToComplete = remainingContainers / avgVelocity;
      const projected = new Date();
      projected.setDate(projected.getDate() + Math.ceil(daysToComplete));
      projectedCompletion = projected.toISOString().split('T')[0];
    }

    return {
      velocity: {
        containersPerDay: Math.round(avgVelocity * 100) / 100,
        containersPerWeek: Math.round(avgVelocity * 7 * 100) / 100,
        trend: avgVelocity > 0 ? 'increasing' : avgVelocity < 0 ? 'decreasing' : 'stable'
      },
      drift: {
        avgHoursPerPeriod: Math.round(avgHourDrift * 100) / 100,
        direction: avgHourDrift > 0 ? 'scope_increasing' : avgHourDrift < 0 ? 'scope_decreasing' : 'stable'
      },
      completion: {
        rate: Math.round(completionRate * 100),
        completed: completedCount,
        total: totalContainers
      },
      projectedCompletion,
      dataPoints: sorted.length,
      periodsCovered: sorted.length - 1
    };
  }
}

const midpServiceInstance = new MIDPService();

// Export methods for testing
module.exports = midpServiceInstance;
module.exports.aggregateTIDPs = midpServiceInstance.aggregateTIDPs.bind(midpServiceInstance);
module.exports.checkDelayImpact = midpServiceInstance.checkDelayImpact.bind(midpServiceInstance);